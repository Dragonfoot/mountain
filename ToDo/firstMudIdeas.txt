email to toetag

Generic Mud Structure

Thinking from an object oriented perspective, an 'area' is basically a collection of 'rooms'. If I expand that a bit, the 'world' becomes much the same, a collection of 'areas'.


'World' being global, responsibility; time, broadcast system, events (weather, news, political, civic, economical), logging, monitoring memory for active and inactive areas (for saving, unloading and reloading), timers, triggers, and perhaps most importantly; a system wide 'tic' called a "heart" here for want of better, which is itself a thread safe object created from scratch. um.. so tic becomes beat.

'Area' would likely have other behaviours and data besides its collection of rooms, yet with perhaps a more focused set of responsibilities, like environmental effects on types of rooms (outdoor/indoor/underground/underwater/flying..), ability to limit/expand sound distances between rooms (hear a fight in across the street if a window or door is open), allow or limit access to chars/mobs based on criteria like levels/groups/size/type, speed limit through exits.

'Room' is a specialized object of collections..its where all the main action happens so its needs are more complex, such as; lists of mobs, players, and items as they come and go, a queue for room messages, another queue for events the room needs to act on, static lists of objects.. IE: exits, traps, triggers, timers, environmental elements (water/gas/poison air..). It would likely also hold static data like; type or class of room, environmental overrides (if its dark, torches can/can't work), maximum chars that can be in it. It will need a local threaded function (queue checker) to perform actions the system or other objects have left in its internal queue for action.

'Exit' is fairly straight forward, at least to start with, early version would likely be a dual link along with static information and a few interactive objects, the links being to rooms it connects, the data being what can or can not be seen while looking "through" or "at" the exit from each side, the interactive objects being a lock type for each 'door', data points could be the exit's breakability when attacked from either room (thirty hits with a scarecrows broomstick vs one concentrated fart from a smirking monk).

The player (char) is the focus element in the program, ..duh on me for saying the obvious. :)  Breaking it down, it's the programs link between itself and the network endpoint the person connects from. Setting it up as a threaded port as its base object would give it the core functionality needed from the start. Char is likely the base object for other interactive types such as admin connections, builders, and mobs. Mobs in particular for admins to control while testing, debugging, and fun trickery on suspected drunk or napping players.

'Char' itself could be derived directly from the port object as said earlier or at the least have a TcpClient as a member, add data points for armour, weapons, health, and the like. It's interactive behaviour and actions are communicated to the 'room' by pushing data packets onto the room's event queue for the room to handle during the heartbeat. Any actions on itself such as checking inventory are handled by its internal functions. Some of its functional behaviour could be imagined here to maybe allow for some further exploration.
 
IE: ...char is ordered to enter a room from the user by receiving a direction or exit via keyboard text, char tells the current room its leaving by posting the event to the event queue, the heart beat, when it passes, pops it and passes the message to the rooms internal queue so the room can know whats needed from it, which, in this case, it does by passing the char's pointer from its char list to the new rooms addChar function and informs relevant objects in this room of the change. Meanwhile the char internally updates its data with the new location and finally sends an 'am in and ready' packet to the new rooms queue. Room responds by passing formatted data to the char's message queue of itself and its viewable contents, and finally sends a new arrival message to all other relevant chars in its list. All this left out the probable checks and balances needed for a char to realistically move between rooms.

The heart could actually do less in the room, and may later on will. We could remove the internal event queue of the room and have all events posted directly to the remaining queue, leaving the heart beat to trigger the rooms check-your-queue function as it leaves. The reason for the two queues at this point is the uncertainty of timings between the expected ofttimes many threads interacting in the room at the same time. So for now its for debugging threads in the room by segregating their areas of behaviour.

Another IE: ...char has been given instructions to pick up an item, char informs the room by adding the an informative data packet to the event queue.. heart pops it and hands it all off to the room for handling, room grabs and processes it by transferring the item to the char's inventory, sends a message to all relevant chars in the room about what they need to know of the event, as well passing a more first person message to the initiating char.

The "event queue" is a way for all objects in a room, threaded or not, to interact with each other in real time via the heart without the system locking up because of thread collisions or at the least by corrupting data like, say.. you seeing a message you have just killed the mob you were fighting before seeing the strike message that actually killed it, 3 seconds later getting a message showing your strike but no drops. About the same time another player in the room just died from the mob you earlier killed. Next you see is the 'dead' mob beating on your shield with the dead players gory helmet, finally you here a player in the next room shout, "where in 'fruitcakes' did all this come from, yippy!!", him seeing the dead players inventory drop on his floor..  Fantasy? or.. a threadless factoidinal delusion... or maybe just some programmers hell spitting up another misty wink over loose threads.

The heart could pass data directly to the rooms or other objects of course, but doing so means it needs to wait for the return of control from the resulting process which halts the rest of the worlds activities that depend on the heart while it waits. Instead it passes a data packet to the objects internal event queue. As the heart finishes with the room it wakes up the rooms queue checker and continues on to the next room to do the same. The woken queue checker grabs the oldest packet on the queue, determines which function needs its data and instructions, passes it along and goes back to sleep if no more packets are on the queue. The function it has called is in the rooms thread so its not holding things up. If set up right, objects with active threads won't interfere with each other as they run concurrently. The internal room's queue checker is basically a restricted version of the heart - no looping unless there is more than one packet left in the queue.

"Mobs", to me, are char's with the port disabled as suggested earlier, disabled because they could potentially be enabled for admins to connect to for possession. Mobs have functionality that chars don't require as well though. Wander about aimlessly kind of behaviour if they are area mobs like how CoffeeMud coder seems to have done it. Mobs are naturally numerous in mudds of course, so conversely they also need to be rather skimpy memory wise to keep the program happy and free from fighting over discarded memory scraps.

Now what if - farther down the line - mobs might be tasked as assassins, messengers, companions, or perhaps seek revenge for some slight or are scripted to perform actions against a char triggered from other external events, or simply to go amuck and start dealing mayhem as it scrambles around blindly seeking out chars to bash. Tracking a player might be a very neat function to add to a mob early on, the mob being triggered to activate/continue/pause/save/load itself if a player its become associated with connects/disconnects or moves in/out of an area the mob is close to or currently in.

Adding an internal message system with case switches might be a good starting point for it similar perhaps to a rooms event queue, even if it isn't very functional at first. Adding a mapping system to track paths between rooms in the world early on could help, perhaps as part of the world object. For one object to track another is to first know where each is in the world, then to map a list of at least the first few rooms to move towards its target. The mob may not need to do the calculations itself, the world could pass back the next few rooms it needs to attempt to get through and thusly closer when the mob requests a tracking action. The better the mob, the more rooms passed back, the shorter the timer between moves and tracking requests and so on.

Mobs need combat behaviour of course, but also side behaviours like stealing, manipulating items, picking locks, kicking down doors, trading, chatting interactively, random acts of silliness like drooling on your beef sandwich, dry humping a rusty boot, giggling as someone does something new.. you know.. personality quirks like what you do. All of this might well be part of its normal functionality, more so than say an area or room or separately dedicated object controlling it could handle without additional threading and memory needs. All suggesting an internal polling system or timer, event queue to help control and pace events the mob me be asked to do down the road.

An advanced combat mob could be a combination of generic mob and generic combat object. Create a basic combat object that has a few defensive functions and add it to a core mob class, add generic data points to the core mob for derived mobs to use in combat. Derived mobs from this core mob could then override the default combat objects behaviour as needed or and more likely for complex mobs it could swap out the default combat object with a derived one specific to this new mobs intended uses.

Web interface to the mud would be mostly what a stand-alone client need do. The game's interface would be the primary difference, one that converts the raw results normally sent to or receive from the stand-alone into html headers with data and visa-versa. The web site would be a fair sized project, then again so would a stand alone.

If we were to make a client for building and controlling the mud, it would likely be a desktop system that used graphics for the mapper/builder/viewer, charts and reports for data-mining, as well as CMUD console type windows to control, monitor, play, and debug. Would need to start its build early on to keep it in sync with the muds progress.

Otherwise if using a default browser, we'd need to figure how to code html5 graphics and delve a good bit deeper into one or more of the javascript libraries. Just as doable as any other approach. The last option would be to code the mud against the standard ones out there, like CMUD, at least to start with to get some momentum going.


-----

Converting first from c to c++ then perhaps to c# would seem to be the way to go, each step doable sort of, but most of what I've seen suggests they're so radically different (c to any high level managed code) that it cant be easily or completely done, a rewrite being the second best, from scratch the preferred. I tried years ago for weeks to convert a small c program to c++, pointers farked it royally every time and I've no idea if the process or any functions now out there have improved since, rarely a need by others to try converting I'd think.

SharpDevelop IDE would be another way to go, as it does a natural conversion of one code base to another rather well from all accounts so far, but again just between managed code and not sure if java is yet in that list when I think CoffeeMud. Also it's very much only windows based.

I agree, a few persons mud is the way to go I think too, with the core of it having the ability to expand in any direction as needed.

Anyway, like you say, slowly, bit by bit, as the time is available, long term kind of project.. time filling insanity perpetuating mind befuddling fun.

I like.


